<?php
// autoGenetedQuiz.php

$lesson_id = (int)($_GET['lesson_id'] ?? 0);
$file_id   = (int)($_GET['file_id']   ?? 0);

// If file_id is missing, derive it from DB (latest file for the lesson)
if ($lesson_id && !$file_id) {
    require_once __DIR__ . '/config/config.php'; // uses $connection
    $connection->set_charset('utf8mb4');

    $stmt = $connection->prepare("SELECT file_id FROM tbl_lesson_files WHERE lesson_id = ? ORDER BY file_id DESC LIMIT 1");
    $stmt->bind_param("i", $lesson_id);
    $stmt->execute();
    $res = $stmt->get_result();
    if ($res && ($row = $res->fetch_assoc())) {
        $file_id = (int)$row['file_id'];
    }
    $stmt->close();
}

/**
 * 1️⃣  Bring in the lesson/text content.
 *     retrieveFileContent.php now RETURNS the content string.
 */
$text = require __DIR__ . '/retrieveFileContent.php';   // <-- capture return value here

/**
 * 2️⃣  Quiz configuration
 */

// Accept from GET or POST, in either naming you've used
$selectedOption = $_GET['selectedOption']
    ?? $_POST['selectedOption']
    ?? 'Multiple Choice';

$numberOfQuestions = $_GET['numberOfQuestion']
    ?? $_GET['numberofQuestion']
    ?? $_POST['numberOfQuestion']
    ?? $_POST['numberofQuestion']
    ?? 10;

$numberOfQuestions = (int) $numberOfQuestions;
if ($numberOfQuestions < 5)  $numberOfQuestions = 5;
if ($numberOfQuestions > 15) $numberOfQuestions = 15;

// If the rest of your file still references the old name, keep it in sync:
$numberOfQuestion = $numberOfQuestions;

// IMPROVED PROMPT - More specific format requirements
$prompt = "Generate a {$selectedOption} quiz with exactly {$numberOfQuestion} questions based on the following text.

FORMAT REQUIREMENTS:
- Return ONLY valid JSON, no additional text
- Structure: {\"questions\": [{\"question\": \"text\", \"answer\": \"correct answer\"}]}
- For Multiple Choice: include \"choices\": [\"option1\", \"option2\", ...] and \"answer\" should be the correct choice text
- For True/False: \"answer\" should be \"True\" or \"False\"
- For Identification: \"answer\" should be the exact identification term
- For Fill in the Blanks: \"question\" should contain underscores for blanks, \"answer\" should be the missing word/phrase
- DO NOT include answer keys or explanations in the questions
- Questions should be directly based on the provided text

TEXT TO BASE QUIZ ON:
{$text}";

/**
 * 3️⃣  OpenRouter API configuration
 */
$apiKey = "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";
$apiUrl = "https://openrouter.ai/api/v1/chat/completions";

$payload = [
    "model" => "deepseek/deepseek-r1-0528-qwen3-8b:free",
    "messages" => [
        [
            "role" => "system",
            "content" => "You are an assistant that creates quizzes from provided text. You MUST return ONLY valid JSON format, no additional text or explanations."
        ],
        [
            "role" => "user",
            "content" => $prompt
        ]
    ],
    "temperature" => 0.7
];

// 4️⃣  Make the API request using cURL
$ch = curl_init($apiUrl);
curl_setopt_array($ch, [
    CURLOPT_RETURNTRANSFER => true,
    CURLOPT_HTTPHEADER => [
        "Content-Type: application/json",
        "Authorization: Bearer {$apiKey}"
    ],
    CURLOPT_POST => true,
    CURLOPT_POSTFIELDS => json_encode($payload)
]);

$response = curl_exec($ch);
if (curl_errno($ch)) {
    die("Error contacting OpenRouter: " . htmlspecialchars(curl_error($ch)));
}
curl_close($ch);

// 5️⃣  Output or handle the quiz result
$data = json_decode($response, true);

// 1) Get the model's output text (or JSON string)
$rawContent = $data['choices'][0]['message']['content'] ?? '';

// 2) Clean the content - remove any trailing answer key markers
$rawContent = preg_replace('/\*answer key\*.*$/i', '', $rawContent);
$rawContent = preg_replace('/answer key:.*$/i', '', $rawContent);
$rawContent = trim($rawContent);

// 3) Try to parse as JSON
$apiQuiz = json_decode($rawContent, true);
$isJson  = (json_last_error() === JSON_ERROR_NONE && is_array($apiQuiz));

// 4) Normalize to your expected structure
if ($isJson) {
    $questions = normalizeQuizPayload($apiQuiz, $selectedOption, $numberOfQuestions);
} elseif (function_exists('parseQuizText')) {
    $questions = parseQuizText($rawContent, $selectedOption, $numberOfQuestions);
} else {
    echo "<script>alert('Quiz was generated but not in JSON format I can store yet.'); window.location.href='quizzes.php';</script>";
    exit;
}

// 5) Store to DB using your existing transaction helper
try {
    $quizId = storeAutoGeneratedQuiz($connection, (int)$lesson_id, $questions);
    echo "<script>alert('Quiz created successfully!'); window.location.href='quizzes.php';</script>";
    exit;
} catch (Throwable $e) {
    error_log('AutoGen save error: ' . $e->getMessage());
    echo "<script>alert('Failed to save quiz to the database.'); window.location.href='quizzes.php';</script>";
    exit;
}

function normalizeQuizPayload($raw, string $selectedOption, int $limit = 15): array {
    if (is_string($raw)) {
        $decoded = json_decode($raw, true);
        if (json_last_error() === JSON_ERROR_NONE) $raw = $decoded;
    }
    
    // Handle nested structure (common in API responses)
    if (isset($raw['questions']) && is_array($raw['questions'])) {
        $raw = $raw['questions'];
    }
    
    if (!is_array($raw)) $raw = [];

    // Map UI selection to DB enum
    $typeMap = [
        'Multiple Choice'     => 'mcq',
        'Identification'      => 'identification',
        'True or False'       => 'true_false',
        'Fill in the Blanks'  => 'fill_blank',
    ];
    $defaultType = $typeMap[$selectedOption] ?? 'mcq';

    $out = [];
    foreach ($raw as $q) {
        // Clean question text - remove answer key artifacts
        $text = trim($q['question_text'] ?? $q['question'] ?? '');
        $text = preg_replace('/\*answer key\*.*$/i', '', $text);
        $text = preg_replace('/answer key:.*$/i', '', $text);
        $text = trim($text);
        
        if ($text === '') continue;

        // Type determination
        $qtype = $defaultType;

        // Options/answers
        $options = [];
        $choices = $q['choices'] ?? $q['options'] ?? null;
        $answer  = $q['answer']  ?? $q['correct'] ?? $q['correct_answer'] ?? null;

        // TRUE/FALSE
        if ($qtype === 'true_false') {
            $ansTF = is_string($answer) ? strtolower(trim($answer)) : (is_bool($answer) ? ($answer ? 'true' : 'false') : 'true');
            $isTrueCorrect = in_array($ansTF, ['true','t','1','yes'], true);
            $options[] = ['text' => 'True',  'is_correct' => $isTrueCorrect ? 1 : 0];
            $options[] = ['text' => 'False', 'is_correct' => $isTrueCorrect ? 0 : 1];
        }
        // MCQ
        elseif ($qtype === 'mcq' && is_array($choices) && count($choices) > 0) {
            $answerText = is_string($answer) ? trim($answer) : '';
            foreach (array_values($choices) as $idx => $opt) {
                $otext = trim(is_array($opt) ? ($opt['text'] ?? $opt['option'] ?? '') : (string)$opt);
                if ($otext === '') continue;
                
                $isCorrect = 0;
                if ($answerText !== '') {
                    $isCorrect = (strcasecmp(trim($answerText), $otext) === 0) ? 1 : 0;
                } elseif (is_int($answer) && $idx === $answer) {
                    $isCorrect = 1;
                } elseif (is_array($opt) && isset($opt['is_correct'])) {
                    $isCorrect = $opt['is_correct'] ? 1 : 0;
                }
                $options[] = ['text' => $otext, 'is_correct' => $isCorrect];
            }
            
            // Ensure at least one correct
            if (!array_filter($options, fn($o) => !empty($o['is_correct']))) {
                if (isset($options[0])) $options[0]['is_correct'] = 1;
            }
        }
        // Identification / Fill in the Blanks
        else {
            $ansText = '';
            if (is_string($answer)) {
                $ansText = trim($answer);
                // Clean answer text
                $ansText = preg_replace('/\*answer key\*.*$/i', '', $ansText);
                $ansText = preg_replace('/answer key:.*$/i', '', $ansText);
                $ansText = trim($ansText);
            }
            $ansText = $ansText !== '' ? $ansText : 'Correct Answer';
            $options[] = ['text' => $ansText, 'is_correct' => 1];
        }

        // Truncate option_text to 255 for DB safety
        foreach ($options as &$o) {
            $o['text'] = mb_substr($o['text'], 0, 255);
            $o['is_correct'] = !empty($o['is_correct']) ? 1 : 0;
        }

        $out[] = [
            'text'    => $text,
            'type'    => $qtype,
            'options' => $options,
        ];

        if (count($out) >= $limit) break;
    }
    return $out;
}
/**
 * Persist quiz + questions + options in a single transaction.
 * Returns the new quiz_id.
 */
function storeAutoGeneratedQuiz(mysqli $connection, int $lessonId, array $normalizedQuestions): int {
    if ($lessonId <= 0 || empty($normalizedQuestions)) {
        throw new RuntimeException('Missing lesson or questions to store.');
    }

    // Start transaction
    $connection->begin_transaction();
    try {
        // Insert quiz
        $stmtQuiz = $connection->prepare("INSERT INTO tbl_quizzes (lesson_id, is_ai_generated) VALUES (?, 1)");
        $stmtQuiz->bind_param("i", $lessonId);
        $stmtQuiz->execute();
        $quizId = (int)$connection->insert_id;
        $stmtQuiz->close();

        // Prepare question + option statements
        $stmtQ  = $connection->prepare("INSERT INTO tbl_questions (quiz_id, question_text, question_type) VALUES (?, ?, ?)");
        $stmtOp = $connection->prepare("INSERT INTO tbl_question_options (question_id, option_text, is_correct) VALUES (?, ?, ?)");

        foreach ($normalizedQuestions as $q) {
            $qtext = $q['text'];
            $qtype = $q['type']; // 'mcq'|'fill_blank'|'identification'|'true_false'
            $stmtQ->bind_param("iss", $quizId, $qtext, $qtype);
            $stmtQ->execute();
            $questionId = (int)$connection->insert_id;

            foreach ($q['options'] as $opt) {
                $otext = $opt['text'];
                $correct = (int)$opt['is_correct'];
                $stmtOp->bind_param("isi", $questionId, $otext, $correct);
                $stmtOp->execute();
            }
        }

        $stmtQ->close();
        $stmtOp->close();

        // Commit
        $connection->commit();
        return $quizId;

    } catch (Throwable $e) {
        $connection->rollback();
        throw $e;
    }
}

// 5) HELPERS: parsing + storing
function _mapType(string $selectedOption): string {
    $map = [
        'Multiple Choice'    => 'mcq',
        'Identification'     => 'identification',
        'True or False'      => 'true_false',
        'Fill in the Blanks' => 'fill_blank',
    ];
    return $map[$selectedOption] ?? 'mcq';
}

/**
 * Parse a plain-text quiz (with "Answer Key" section) to a normalized structure:
 * [
 *   ['text'=>..., 'type'=>'mcq|identification|true_false|fill_blank',
 *     'options'=>[['text'=>..., 'is_correct'=>0|1], ...]
 *   ],
 *   ...
 * ]
 */
function parseQuizText(string $quizText, string $selectedOption, int $limit = 15): array {
    $type = _mapType($selectedOption);
    $out  = [];

    $txt = preg_replace("/\r\n|\r/", "\n", trim($quizText));
    $parts = preg_split('/\n\s*answer\s*key\s*:?\s*\n/i', $txt, 2);
    $body  = $parts[0];
    $answerBlock = $parts[1] ?? '';

    $answers = [];
    if ($answerBlock !== '') {
        foreach (preg_split('/\n+/', trim($answerBlock)) as $line) {
            if (preg_match('/^\s*(\d+)[\)\.\-]?\s*[:\-]?\s*(.+)\s*$/i', $line, $m)) {
                $qnum = (int)$m[1];
                $ans  = trim($m[2]);
                if (preg_match('/^[A-D]$/i', $ans)) $ans = strtoupper($ans);
                if (preg_match('/^(true|t|1|yes)$/i', $ans))  $ans = 'True';
                if (preg_match('/^(false|f|0|no)$/i', $ans))  $ans = 'False';
                $answers[$qnum] = $ans;
            }
        }
    }

    $blocks = preg_split('/\n(?=\s*\d+[\)\.\-]\s+)/', "\n".$body);
    foreach ($blocks as $block) {
        $block = trim($block);
        if ($block === '') continue;
        if (!preg_match('/^\s*(\d+)[\)\.\-]\s*(.+)$/s', $block, $m)) continue;

        $qnum  = (int)$m[1];
        $qtext = trim($m[2]);
        $options = [];

        if ($type === 'mcq') {
            $lines = preg_split('/\n+/', $qtext);
            $stem = [];
            foreach ($lines as $ln) {
                if (preg_match('/^\s*([A-D])[\)\.\-:]\s*(.+)$/i', $ln, $om)) {
                    $letter = strtoupper($om[1]);
                    $optTxt = trim($om[2]);
                    $isCorrect = (isset($answers[$qnum]) && strtoupper($answers[$qnum]) === $letter) ? 1 : 0;
                    $options[] = ['text' => mb_substr($optTxt, 0, 255), 'is_correct' => $isCorrect];
                } else {
                    $stem[] = $ln;
                }
            }
            $qtext = trim(implode("\n", $stem));
            if (empty($options)) {
                // Try bullet list as fallback
                foreach ($lines as $ln) {
                    if (preg_match('/^\s*[\-\*\•]\s*(.+)$/', $ln, $om)) {
                        $optTxt = trim($om[1]);
                        $options[] = ['text' => mb_substr($optTxt, 0, 255), 'is_correct' => 0];
                    }
                }
                if (empty($options)) {
                    // Last resort: True/False
                    $options[] = ['text' => 'True',  'is_correct' => (isset($answers[$qnum]) && $answers[$qnum] === 'True') ? 1 : 0];
                    $options[] = ['text' => 'False', 'is_correct' => (isset($answers[$qnum]) && $answers[$qnum] === 'False') ? 1 : 0];
                }
            }
            if (!array_filter($options, fn($o) => !empty($o['is_correct']))) {
                if (isset($options[0])) $options[0]['is_correct'] = 1;
            }
        } elseif ($type === 'true_false') {
            $isTrueCorrect = isset($answers[$qnum]) ? (strcasecmp($answers[$qnum], 'True') === 0) : true;
            $options[] = ['text' => 'True',  'is_correct' => $isTrueCorrect ? 1 : 0];
            $options[] = ['text' => 'False', 'is_correct' => $isTrueCorrect ? 0 : 1];
        } else {
            // identification / fill_blank
            $ansText = $answers[$qnum] ?? '';
            if ($ansText === '') {
                if (preg_match('/answer\s*[:\-]\s*(.+)$/i', $qtext, $am)) {
                    $ansText = trim($am[1]);
                    $qtext = trim(preg_replace('/answer\s*[:\-]\s*.+$/i', '', $qtext));
                } else {
                    $ansText = '[answer]';
                }
            }
            $options[] = ['text' => mb_substr($ansText, 0, 255), 'is_correct' => 1];
        }

        $out[] = [
            'text'    => $qtext,
            'type'    => $type,
            'options' => $options,
        ];

        if (count($out) >= $limit) break;
    }

    return $out;
}